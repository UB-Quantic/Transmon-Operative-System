# Author: Xabier Oyanguren Asua <oiangu9@gmail.com>

import numpy as np
import State
import scipy.optimize as opt
import Labber as Labber
import os as os
from SingleQubit_Control_Externaly_Importable_Pulse_Seq import PulseSequencetoTxtConversor

class SingleSuperconductingQubitExperiment:
    """ A class that façades the translation of generic algorithmic orders
    to the actual analogical transmon like superconducting qubit implementation. 
    
    Parameters
    ---------
    drag : Boolean , default=True
        If True, DRAG pulsing will be used during capacitive coupling. Note
        that in this case, a drag beta callibration (to reduce leakage) will 
        be required, which might take an undesired time
    
    Attributes
    ---------
    circuitParameters : python dictionary
        This dictionary contains the empyric data of the transmon circuit, and
        it is generated out of the external txt file "CircuitParams.txt" 
        generated by the QComputer's admin when initializing the server. It 
        should conatin the following entries:
            'QubitFrequency' : real double
                The qubit transition frequency
            'Anharmonicity': real double
                The anharmonicity of the particular Transmon
            
    deviceSpecs : python dictionary
        This dictionary contains the specific hardware parameters required for
        generating and sending the correct pulses. It is generated using the 
        information of the external file "DeviceParams.txt". The expected 
        entries are:
            'AWG_SampleRate': real double
                It is the sample rate of the specific AWG to be used in seconds^-1
            'wSSB': real double
                The frequency to be set in the pulses shaped by the AWG for the
                single sideband micing in the IQ mixer
        
    Xpi_2Pulse : python dictionary
        Dictionary containing the optimized parameters to generate the X pi/2
        microwave pulses. The dictionary should include the following data:
            'T': real double
                Half the time duration of the gaussian pulse in seconds
            'V0': real double
                Scalar amplitude of the pulse in Volts
            'BufferBetweenPulses': real double
                Time between succesive drive pulses in seconds
    
    dragBeta : real double
        It is the scaling factor for the DRAG pulse. For more info see refs.
        [1] or [2].
    
    NOTE
    ----
        Throughout the class, it will always be assumed that operator matrixes
    are expressed in the computational basis [|0>,|1>] of the quantization axis
    depicted by the z axis in the Bloch Sphere
    
    TODO
    ----
        - A calibration for the pulses should be implemented, as the pulse that
    leaves out the devices is not really the pulse arriving to the qubit! This
    shall be done with the method _calibrateXPulse used in the init.
       - The DRaG callibration funciton needs also to be written! This method
    should obtain the optimal drag beta parameter for reducing leakage errors
    when driving the qubit.
       - Implement dynamical pulsing to block decoherenig effects by longitudinal
    noise. DragZ pulsing is an alternative to this.
       - Implement a Qubit simulator to see the theoretical effects on the Bloch
    sphere due to the sent pulses (Labber apparently has a module for this).
       - Support for mixed states should be implemented, as well as a more general
    class for an N qubit system (for now, the Lab only has a single qubit, so
    this class covers all the possible operations on it).
       - DRAGZ may be imnplemented in order to get both Stark shift and
    leakage correcitons working at once
       - Should there be an initial calibration funciton for getting the qubit
    resonace freqcy, T1,T2... etc, or rather this will be done already externally
    and these parameters will be updated in the txt file from where the class
    will read them? Ideally, if this is to be used by programers remotely, 
    maybe in each program (for each created singlequbit instance) a full 
    calibration should be performed?

    NOTE!
    -----
    #SHOULD READOUT BE DONE SEPARATEDLY OF DRIVE? making them in the same
    function is required for the arm/trig way. If instead coupling and readout 
    are done in different Labber config files, or in the case the other way of
    manipulating Labber through scripts is finally better to use (as described
    in the last section of this script), perhaps dividing drive and readout
    in two methods is more convenient, such that the external user can directly
    choose to make a readout or not after driving the qubit...if this has any use.
    
    BIBLIOGRAPHY
    (for the Qubit Control scheme by Capacitive Coupling and Virtual Z gating)
    ---------
    [1] - P. Krantz, M. Kjaergaard, F. Yan, T. P. Orlando, S. Gustavsson, and
    W. D. Oliver, A quantum engineer’s guide to superconducting qubits, 
    Appl. Phys. Rev. 6, 021318 (2019).
    
    [2] - McKay, D. C., Wood, C. J., Sheldon, S., Chow, J. M. & Gambetta, J. M. 
    Efficient Z-gates for quantum computing. Preprint at 
    https://arxiv.org/abs/1612.00858 (2017)
    
    [3] - Michael A. Nielsen , Isaac L. Chuang, Quantum Computation and Quantum 
    Information, Cambridge University Press, 2001
    
    EXAMPLE
    -------
    An example of usage of this class: The preparation of a |+> State and 
    measurement of the sate:
        
        myQubit = SingleSuperconductingQubitExperiment()
        result = myQubit.driveQubitTo( wishedAlpha=1/np.sqrt(2), wishedBeta=1/np.sqrt(2))
        print('The qubit-s state is',result)
        
    """
    
    
    def __init__(self, drag=True): #simulation=False, dragz=False, dynamical=False):

        self.drag = drag
        
        # at instance initialization, the parameters of the transmon should be
        # extracted from the local file generated during the calibration of the
        # system when the server was initialized by the QC admin
        
        self.circuitParameters = self._extractParamsFromFile("CircuitParams.txt")
        self.deviceSpecs = self._extractParamsFromFile("DeviceParams.txt")
        
        self.Xpi_2pulse = self._calibrateXPulse() #dictionary with the required T...
        if (drag):
            self.dragBeta = self._calibrateDragBeta()
        
    def driveQubitTo(self, wishedAlpha, wishedBeta, initialAlpha=1, initialBeta=0):
        """Given a desired final state vector, in three steps, this method
        realizes the physical single qubit rotation using the virtual Z gate
        strategy that follows: 
            
        a) logical compilation:
         - generation of the required single rotation matrix, 
         - translation of this rotation to a series of two pi/2 X gates 
         alternated in between three Z gates with certain angles
         
        b) analogical compilation:
         - using the fact that Z gates that are followed by single qubit gates
         can be implemented in superconducting qubits in the capacitive coupling
         as an additional relative phase applied to the coming driving pulses;
         the sequence of Z and X pi/2 gates is translated to two pi/2 pulses
         that have the additional necessary phases. So, the rotation is
         translated into a pair of microwave pulses
         
        c) physical execution of the experiment
         - Communication is established with the Instrument Server of Labber, 
         and channels to the particular devices are enabled
         - Pulses are sent to the driving devices, and they are armed to wait
         until the trigger
         - Logging channels are armed as well to allow inmediate readout
         - The trigger is sent and the interaction with the physical qubit begins
         - The readout signal is anlayzed and the method outputs the relevant
         information
         
         Arguments
         ---------
         wishedAlpha : double (Complex)
             The projection on the |0> basis state we wish the qubit to drive to
         wishedBeta : double (Complex)
             The projection on the |1> basis state we wish the state to drive to
        
         Outputs
         -------
         The measurement's result
        
        """
        # should it be established a timer to avoid calling this method too 
        # fast? I mean, in order to leave the qubit enough time to return to
        # the ground state, perhaps it should be an option -> needed another
        # parameter in the fucntion to set timer or not. The point is, how much
        # time? Perhaps to avoid limiting the speed with an unfortunate overestiamte
        # the best is to let the user the option to set the timer duratoin as well
        
        ## while(timer doesnt finish):
            ## timer get time
            
        initialState = State.PureState(initialAlpha, initialBeta)
        finalState = State.PureState(alpha=wishedAlpha, beta=wishedBeta) 
        
        atOnceRotation = self._getRotationMatrix(initialState, finalState)
        
        Xpi_2ZgateSequence = self._logicalCompilationToXpi_2Z(atOnceRotation)
        
        pulseSeq = self._analogicalCompilationVZgates(Xpi_2ZgateSequence)
        
        measurementOutput = self.executeExperiment(pulseSeq)

        # initialize timer
        
        return measurementOutput
    
    def executeUnitaryOperation(self,operation):
        """It is the same method as executeRotation, but here one can directly
        input a desired operation on the initial ground state |0> of the qubit,
        instead of having to give in the output state.
        
        Argument
        -------
        operation : numpyArray, shape(2,2) Complex
            The unitary operation one wishes to apply to the qubit, written as
            a matrix in the computational basis
        
        Outputs
        ------
        The measurement's result
        
        """
        Xpi_2ZgateSequence = self._logicalCompilationToXpi_2Z(operation)
        
        pulseSeq = self._analogicalCompilationVZgates(Xpi_2ZgateSequence)
        
        measurementOutput = self.executeExperiment(pulseSeq)  
        
        return measurementOutput
    
    def _getRotationMatrix(self, initialState, finalState):
        """
        Method that returns one of the possible unitary evolution matrixes, U 
        required to evolve the given initial state to the final state:
            
            U |initialState> = |finalState>
        
        Any unitary transormation on a Single qubit Bloch sphere can be seen 
        as a rotation of a certain angle theta (t) about a particular axis 
        defined by the real unit vector n=(nx,ny,nz) on the sphere. 
        
        Rn(t) = exp(-i t*n*sig/2) = cos(t/2)*I - i*sin(t/2)*(nx*X+ny*Y+nz*Z)
        
        where sig denotes the three component vector of Pauli matrices (X,Y,Z).
        Thus, the function solves the system of equations in the Comput. basis:
        Rn(t) |initialState> = |finalState>
        with unknowns t, n=(nx,ny,nz) , using numpy functions
        
        References
        ---------
        - Bibl. [3]
        
        Parameters
        ----------
        initialState : State
            The state of the wave-vector at time zero of the unitary evolution
        
        finalState : State
            The desired statevector inmediately post-evolution
            
        Returns
        -------
        U (singleUnitaryOperator) : NumpyArray, shape(2,2) (matrix on Complex)
            A matrix in the Computational Basis that expresses the single 
            transformation needed for the change |initialState> -> |finalState>
            
        """
        def Rnt(t,nx,ny,nz):
            return np.array([[np.cos(t/2)-1j*nz*np.sin(t/2),-np.sin(t/2)*(ny+1j*nx)]
                              ,[-np.sin(t/2)*(1j*nx-ny),np.cos(t/2)+1j*nz*np.sin(t/2)]])
    
        vect_ini = initialState.getAmplitudes().flatten()
        re_ini = vect_ini.real
        im_ini = vec_ini.imag
        vect_fin = finalState.getAmplitudes().flatten()
        re_fin = vect_fin.real
        im_fin = vect_fin.imag
        def Rnt(t,nx,ny,nz):
            return np.array([[np.cos(t/2)-1j*nz*np.sin(t/2),-np.sin(t/2)*(ny+1j*nx)]
                   ,[-np.sin(t/2)*(1j*nx-ny),np.cos(t/2)+1j*nz*np.sin(t/2)]])  
        def F(unknowns):
            (t,nx,ny,nz) = unknowns
            A = np.array([[re_ini[0],im_ini[0],-re_ini[1],im_ini[1]],
                         [im_ini[0],-re_ini[0],-im_ini[1],-re_ini[1]],
                         [re_ini[1],-im_ini[1],re_ini[0],im_ini[0]],
                         [im_ini[1],re_ini[1],im_ini[0],-re_ini[0]]])
            x = np.array([[np.cos(t/2)],[0],[0],[0]])+np.sin(t/2)*np.array([[0],[nz],[ny],[nx]])
            B = np.array([[re_fin[0]],[im_fin[0]],[re_fin[1]],[im_fin[1]]])
            return (np.dot(A,x)-B).flatten().tolist()
        
        solut = opt.fsolve(F,[np.pi/4,1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)])
        #norm = np.sqrt(solut[1]**2+solut[2]**2+solut[3]**2)
        #(solut[1],solut[2],solut[3])=(solut[1]/norm,solut[2]/norm,solut[3]/norm)
        return Rnt(solut[0],solut[1],solut[2],solut[3])
        
            
    def _logicalCompilationToXpi_2Z(self,unitary):
        """Given an input unitary transormation expressed as a matrix in the 
        computational basis, this rutine obtains the parameters t (theta),
        g (gamma), p (phi), l (lambda), that satisfy the following theorem:
            
            Any arbitrary SU(2) gate can be written as:
                U(t,g,p,l) = [[cos(t/2), -i*exp(i*l)*sin(t/2)],
                              [-i*exp(i*p)*sin(t/2), exp(i*(l+p))*cos(t/2)]]
            which up to a global phase is represented as:
                U(t,p,l) = Z(p) X (t) Z(l)
            where Z(j),X(j) represent rotations about Z and X of angle j
            Gate identies yield:
                U(t,p,l) = Z(p-pi/2) X (pi/2) Z(pi-t) X(pi/2) Z(l-pi/2)
            Thus, knowing t,p,l we are able to compile any single qubit
            operation into a sequence of two pi/2 X gates and Z gates (that
            ideally can be implemented as Virtual Z gates, s.t. effectively
            the only driving pulses required to perform the operation 
            will be two pi/2 X pulses)
        
        References
        -------
        - Bibl. [2]
        
        Arguments
        --------
        unitary : NumpyArray, shape(2,2) Complex
            It is the unitary operation we want to translate
            
        Output
        ------
        : tuple (a,b,c,d,e) real doubles
            The rotation angles for the respective (Z,X,Z,X,Z) gate tuple of
            the theorem. Note b,d are pi/2 always
        
        """
        def F(unknowns):
            (t, g, p, l, d1,d2,d3,d4) = unknowns # d1,..d4 are dummie variables to satisfy the numpy function
            f1=np.cos(t/2)*np.cos(g)-unitary.real[0,0]
            f2=np.cos(t/2)*np.sin(g)-unitary.imag[0,0]
            f3=np.sin(t/2)*(np.cos(p)*np.sin(g)+np.sin(p)*np.cos(g))-unitary.real[1,0]
            f4=np.sin(t/2)*(np.sin(p)*np.sin(g)-np.cos(p)*np.cos(g))-unitary.imag[1,0]
            f5=np.sin(t/2)*(np.cos(l)*np.sin(g)+np.sin(l)*np.cos(g))-unitary.real[0,1]
            f6=np.sin(t/2)*(np.sin(l)*np.sin(g)-np.cos(l)*np.cos(g))-unitary.imag[0,1]
            f7=np.cos(t/2)*(np.cos(l+p)*np.cos(g)-np.sin(l+p)*np.sin(g))-unitary.real[1,1]
            f8=np.cos(t/2)*(np.cos(l+p)*np.sin(g)+np.sin(l+p)*np.cos(g))-unitary.imag[1,1]
            return [f1,f2,f3,f4,f5,f6,f7,f8]
        solut = opt.fsolve(F,[np.pi/4,np.pi/4,np.pi/4,np.pi/4,1,1,1,1])
        (t,g,p,l)=solut[:5]
        return (p-np.pi/2, np.pi/2, np.pi-t, np.pi/2, l-np.pi/2)
        
    def _analogicalCompilation(self,ZXZXZdecompositionAngles):
        """Method that prepares the I,Q pulses for the AWG and the frequency
        of the LO, so they can be sent to the devices.
        
        It is called analogical compilation since it translates the sequence
        of Z(p-pi/2) X (pi/2) Z(pi-t) X(pi/2) Z(l-pi/2) gates outputed by the
        logical compiler into the actual microwave pulses that will drive the
        rotation in the real transmon qubit.
        In particular, note that it is here where virtual Z gating is applied
        by forgetting about the three Z gates, and instead adding their 
        rotation angles as relative phases to the pi/2 X pulses, as described
        in the bibliography paper [1].
        More in particular still, as before and after this gate sequence we
        will not apply any additional operation, the only Z gate that is
        relevant is the one in between the two finite time X gates, and thus
        the only angle we shall care about of the ZXZXZ decomposition is the
        theta described in the logical compilation function. Thus, for our
        purposes:
        Z(p-pi/2) X (pi/2) Z(pi-t) X(pi/2) Z(l-pi/2) ~ X (pi/2) Z(pi-t) X(pi/2)
        And thus, this can be implemented by just two pulses:
            X(pi/2 rot, with pi-t phase relative to) X(pi/2 rot)
        
        As DRAG pulsing may be used, the pulse envelope is set to be a Gaussian
        for convenience with the derivative, following its use in bibl. [2].
        The X pulses are designed following the indications in bibl. [1]
        by sending the drivng signal entirely in the I quadrature of the
        resulting drive pulse post I/Q mixing, while the drag part occupies 
        the Q quadrature.
        
        We assume the following IQ mixing scheme:
        > Inputs in the mixer:
            LO(t) = cos(wLO* t);
            I(t);
            Q(t);
        > Output RF:
            Vdrive(t) = I(t)*cos(wLO*t) + Q(t)*cos(wLO*t + pi/2) =
                    = I(t)*cos(wLO*t) - Q(t)*sin(wLO*t)
        
        Following ref [1], for the purposes of an X theta rotation, the resulting
        form RF, aka the drive pulse, must only be formed on the I quadrature:
            
            Vdrive(t) = V0 s(t)*sin(wd *t)
            
            where V0 is the scalar amplitude, s(t) is the envelope function 
            modulating the RF and wd is the drive frequency.
            
            The drive frequency wd must be equal to the qubit resonance
        frequency wq, to drive the rotation around the x axis of the Bloch Sph.
            If no DRAG is wished to be applied, then such a drive pulse may
        be obtained by single side-band modulation SSB, using an IQ mixer, and
        choosing wd = wLO + wAWG, by:
            
            I(t) = V0 s(t) sin(wAWG*t)
            Q(t) = -V0 s(t) cos(wAWG*t)
            
            Result:
                Vd(t) = V0 s(t) sin([wAWG+wLO]t) as wished
            
            If a DRAG correcting pulse is applied, then for the X rotation pulse,
        the resulting drive pulse must have a Q quadrature modulated by V0 times
        the time derivative of the envelope at I, that's ds(t)/dt, times a factor
        beta that's equal to an optimum scalar divided by the anharmonicity of
        the qubit. Thus:
            
            Vd(t) = V0 s(t)*sin(wd *t) + beta* V0*ds(t)/dt*sin(wd *t + pi/2)
            
        which can be obtained in the mixing if the AWG introduces in the mixer:
            
            I(t) = V0 s(t) sin(wAWG*t) + beta* V0*ds(t)/dt*sin(wAWG *t + pi/2)
            Q(t) = - V0 s(t) cos(wAWG*t) - beta* V0*ds(t)/dt*cos(wAWG *t + pi/2)
        
        If then one wishes to introduce a relative phase (for the second pulse
        in our case) with respect to the phase dicatated by the LO (respect
        to the first pulse), if we add that phase to the I(t) and Q(t) pulses
        then it will appear as well in the resulting drive. For the general
        case considered (with DRAG), if we send to the mixing:
            
            I(t) = V0 s(t) sin(wAWG*t + theta) + beta* V0*ds(t)/dt*sin(wAWG *t + pi/2 + theta)
            Q(t) = - V0 s(t) cos(wAWG*t + theta) - beta* V0*ds(t)/dt*cos(wAWG *t + pi/2 + theta)
        
        the IQ mixing will yield:
            
            Vd(t) = V0 s(t)*sin(wd *t + theta) + beta* V0*ds(t)/dt*sin(wd *t + pi/2 + theta)
            
        These I(t) and Q(t) are precisely the ones used in this method.
        
        References
        ---------
        - Bibl. [1] and [2]
        
        Arguments
        --------
        ZXZXZdecompositionAngles : tuple (a,b,c,d,e) real doubles
            The rotation angles for the respective (Z,X,Z,X,Z) gate tuple of
            the U(a,b,c,d,e) = Z(a) X (b) Z(c) X(d) Z(e) decomposition with
            b,d= pi/2 in all cases
        
        Outputs
        -------
        python dictionary 
            Containing the following data:
            'I1' : NumpyArray, shape(1,) real doubles
                The pulse amplitude samples to be sent to the AWG for the I
                quadrature
            'Q1' : NumpyArray, shape(1,) real doubles
                The pulse amplitude samples to be sent to the AWG for the Q
                quadrature
            't_AWG' : NumpyArray, shape(1,) real doubles
                The time points for the pulses by the AWG
            't_LO' : NumpyArray, shape(1,) real doubles
                The time points for the pulses by the LO
            'wLO' : double
                The frequency that will be ordered to the local oscillator
        
        """

        T = self.Xpi_2Pulse["T"]
        bufferBetweenPulses = self.Xpi_2Pulse["BufferBetweenPulses"]
        wawg = self.deviceSpecs['wSSB']
        wLO = self.circuitParameters['QubitFrequency'] - wawg # wssb+wLO = wqubit
        V0 = self.Xpi_2Pulse['V0']
        phase_2_pulse = ZXZXZdecompositionAngles[2]
        sampleRate = self.deviceSpecs['AWG_SampleRate']
        n_points=(2*T + bufferBetweenPulses + 2*T)*sampleRate #total length of the sequence aka #time divisions
        beta = self._dragBeta
        
        def GaussianEnvelope(t,V0,T,sigma=T/4):
            """Method that returns the amplitude of a Gaussian Envelope 
            with parameters V0,T,sigma for a time t where:
                -t is the time of interest
                -V0 is the scalar amplitude of the pulse
                -T is HALF the pulse length, usualy set to T = 4*sigma
                -sigma is the standard deviation of the pulse
            """
            return V0*(np.exp(-(t-T)**2/(2*sigma**2))-np.exp(-T**2/(2*sigma**2)))/(1-np.exp(-T**2/(2*sigma**2)))
        
        def DerivativeGaussianEnvelope(t,V0,T,sigma=T/4):
            return -V0*(T-t)*np.exp(-(T-t)**2/(2*sigma**2))/(sigma**2*(np.exp(-T**2/(2*sigma**2))-1))
        
        timeAWG = np.linspace(0, 2*T + bufferBetweenPulses + 2*T, num=int(n_points))
        
        Ipulses=[]
        Qpulses=[]
        # we fill the pulse "arrays" with voltage amplitudes
        for t in timeAWG:
            if t < 2*T:
                Ipulses.append(GaussianEnvelope(t,V0,T)*np.sin(wawg*t)) # first pulse (I channel)
                Qpulses.append(-GaussianEnvelope(t,V0,T)*np.cos(wawg*t)) # first pulse (Q channel)

            elif t < 2*T + bufferBetweenPulses:
                Ipulses.append(0.0) # buffer in between
                Qpulses.append(0.0)
            else:
                Ipulses.append(GaussianEnvelope(t-(2*T + bufferBetweenPulses),V0,T)*np.sin(wawg*(t-(2*T + bufferBetweenPulses))+phase_2_pulse)) # second pulse (I channel)
                Qpulses.append(-GaussianEnvelope(t-(2*T + bufferBetweenPulses),V0,T)*np.cos(wawg*(t-(2*T + bufferBetweenPulses))+phase_2_pulse)) # second pulse (Q channel)
           
        if(self.drag):
            for i,t in enumerate(timeAWG):
                if t < 2*T:
                    Ipulses[i]+= beta*DerivativeGaussianEnvelope(t,V0,T)*np.sin(wawg*t+np.pi/2) # first pulse (I channel)
                    Qpulses[i]+= -beta*DerivativeGaussianEnvelope(t,V0,T)*np.cos(wawg*t+np.pi/2) # first pulse (Q channel)
    
                elif t > 2*T + bufferBetweenPulses:
                    Ipulses[i]+= beta*DerivativeGaussianEnvelope(t-(2*T + bufferBetweenPulses),V0,T)*np.sin(wawg*(t-(2*T + bufferBetweenPulses))+np.pi/2+phase_2_pulse) # second pulse (I channel)
                    Qpulses[i]+= -beta*DerivativeGaussianEnvelope(t-(2*T + bufferBetweenPulses),V0,T)*np.cos(wawg*(t-(2*T + bufferBetweenPulses))+phase_2_pulse+np.pi/2) # second pulse (Q channel)
               
                
        return {'I1':Ipulses, 'Q1':Qpulses, 't_LO':timeLo, 't_AWG':timeAWG, 'wLO':wLO}
        
    def executeExperiment(self, pulseSeq):
        """ Method that drives the experimental steps using Labber.
        The method relies on a pre-existing Labber Measurement Setup file named
        'PulseSender.hdf5' that should be located in the same directory as this
        script.
        The 'PulseSender.hdf5' measurement should communicate with all the
        specific hardware (AWGs, LOs, Network Analizers...) required to correctly
        send drive and readout pulses to the qubit and demodulate the arriving
        signal to determine the sate of the qubit.
        The method just generates the txt file with the desired pulse sequences
        for the I/Q mixing, and orders the execution of the Labber Measurement
        Editor.
        
        NOTE
        ----
        Note that the method assumes that the custom signal generator driver
        "SingleQubit_Control_Externaly_Importable_Pulse_Seq" is correctly
        installed in its corresponding custom driver Labber directory.
        Also the method assumes that this same package has been added to
        python path in the interpreter, such that 
        "from SingleQubit_Control_Externaly_Importable_Pulse_Seq import 
        PulseSequencetoTxtConversor.PulseSequencetoTxtConversor"
        can be succesfully executed.

        Arguments
        --------
        pulseSeq : python dictionary with entries:
            'I' : NumpyArray, shape(1,) real doubles
                The pulse amplitude samples to be sent to the AWG for the I
                quadrature
            'Q' : NumpyArray, shape(1,) real doubles
                The pulse amplitude samples to be sent to the AWG for the Q
                quadrature
            'wLO' : double
                The frequency that will be ordered to the local oscillator
        
        Outputs
        ------
        The measurement result (posibly the phase shift measured on the reflected
        readout tone, which suggests the state of the qubit with respect to the
        quantization axis)
                
        """
        #TODO Should the devices already be initialized in the Instrument Server
        # when the measurement exe is run? If yes, then an explicit instument
        # communication should be coded first (like the one suggested in the
        # idea box at the end of the script)
        
        # The txt file with the array data correctly formatted is generated
        # first. Thus, to begin, a dictionary with the correct layout for 
        # the class PulseSequenceToTxtConversor is generated (we reuse the given
        # input dictionary)
        pulseSeq['SampleRate'] = self.deviceSpecs['AWG_SampleRate']
        pulseSeq['OutputNumber'] = 1
        converter = PulseSequencetoTxtConversor.PulseSequencetoTxtConversor()
        converter.convertDicArraysToTxt(pulseSeq)
        
        # Next the predefined Labber configuration file generated ad hoc can be 
        # already executed
        Labber.ScriptTools.setExePath('C:\Program Files (x86)\Labber\Program')
        scriptPath = os.path.dirname(os.path.abspath(__file__))
        SSBdriving = ScriptTools.MeasurementObject(os.path.join(scriptPath,\
                                                          'PulseSender.hdf5'))
        IQLOdriving.updateValue('LO w', pulseSeq['w_LO'])
       
        (x,y) = IQLOdriving.performMeasurement()
        
        return (x,y)
    
    def _extractParamsFromFile(self,file_name):
        """Method that reads a data file named "file_name" and extracts the 
        parameters and respective numeric values listed there in the following
        format:
            NameOfParameter numericValue
            NameOfParameter2 numericValue
        where the numeric value is expected to be given in any of the following
        formats:
            8
            2.71828
            8.23e-07
            8e-7
        Collected data are registered in a Python dictionary.
        
        Argument
        --------
        file_name : string
        
        Output
        -----
        params : python dictionary
            with key='NameOfParameter', value= NumericValue (float)
        
        """
        datafile = open(file_name,"r")
        params={}
        for line in datafile:
            name=''
            i=0
            while(line[i]!=' '):
                name+=line[i]
                i+=1
            i+=1
            number=''
            while(line[i]!='e' and line[i]!='\n'):
                number+=line[i]
                i+=1
            number=float(number)
            if(line[i]=='e'):
                i+=1
                exponent=''
                while(line[i]!='\n'):
                    exponent+=line[i]
                    i+=1
                exponent=float(exponent)
                params[name] = number*10**exponent
            else:
                params[name] = number
        datafile.close()    
        return params
        
    def _calibrateDragBeta(self):
        # TODO
        # Given omega, V0 and anharmonicity a, and the correct pi/2 pulse
        # leakage measurements swept with varying beta in [-2,2]
        # A test could be made by applying an identity roation, 
        # decomposed in two pi/2 pulses and see the resulting leakage
        # the best record will correspond to the optimized beta
        
    def _calibrateXPulse(self):
        # TODO
        # calculate the optimal pulse length T, amplitude V0 and buffer between 
        # successive pulses
        
''' ---------------------------------------------------------------------------
    EXTRA IDEAS
    -----------------

Labber gives another way to control the instruments through scripts other than
by calling saved MEasurement .hdf5 files: by directly controlling hte devices.
This way is perhaps more convenient, if so, a skeleton for changing the
executeExperiment method is offered here
        
     def executeExperiment(self,pulseSeq):
        
        devices = self._establishCommunication()
        
        self._armDevices(devices, pulseSeq)
        
        # self._armReadoutDevices(devices)
        
        triggerON
        
        return self._signalAnalyzer(devices)
    
    def _establishCommunication():
        """Method that makes sure Labber instrument server is running and
        establishes connection with the driving and readout devices.
            Note that the exact model names and network interface adresses
        are extracted from the external file "DeviceParams.txt".
        Returns
        ------
        python dict with entries:
            'AWG' : Labber.InstrumentClient object
                An object associated to the specific AWG used
            'LO' : Labber.InstrumentClient object
                An object associated to the specific LO used
            'client' : Labber.LabberBlockingClient object
                The reference that controls the Instrument Server
        
        """
        #TODO : Force Labber Instrument Server to initialize
        client = Labber.connectToServer('localhost')
        AWG = client.connectToInstrument(self.deviceSpecs['AWG'],
                                         dict(interface=self.deviceSpecs['AWG_interf'],
                                              adress=self.deviceSpecs['AWG_adress'], 
                                              startup='Set config', lockbool=True),
                                              bCreatenew=True)
        LO = client.connectToInstrument(self.deviceSpecs['LO'],
                                        dict(interface=self.deviceSpecs['LO_interf'],
                                             adress=self.deviceSpecs['LO_adress'], 
                                             startup='Set config', lockbool=True),
                                             bCreatenew=True)
        return {'AWG':AWG, 'LO':LO, 'client':client}
    
    def _armDevices(self,devices,pulseSeq):
        """Method that sets the parameters of each device and orders them to 
        wait until the trigger signal arrives in order to carry out them 
        simultaneously.
        
        Arguments
        --------
        devices : python dictionary with entries:
            'AWG' : Labber.InstrumentClient object
                An object associated to the specific AWG used
            'LO' : labber.InstrumentClient object
                An object associated to the specific LO used
            'client' : Labber.LabberBlockingClient object
                The reference that controls the Instrument Server
        
        pulseSeq : python dictionary with entries:
            'I' : NumpyArray, shape(1,) real doubles
                The pulse amplitude samples to be sent to the AWG for the I
                quadrature
            'Q' : NumpyArray, shape(1,) real doubles
                The pulse amplitude samples to be sent to the AWG for the Q
                quadrature
            't_AWG' : NumpyArray, shape(1,) real doubles
                The time points for the pulses by the AWG
            't_LO' : NumpyArray, shape(1,) real doubles
                The time points for the pulses by the LO
            'wLO' : double
                The frequency that will be ordered to the local oscillator
        
        """
        devices['AWG'].arm()
        device['AWG'].setInstrConfig()
        devices['AWG'].startInstrument()
        # AWG and measurement devices should now be armed and connected to the
        # trigger of the LO, such that, when the LO is activated everything
        # gets on

'''